shader BMFont_ShaderFX : BMFont_Provider, TransformationBase, VertexIDStream, CharPlacementStruct, BMFont, Transformation
{
	rgroup PerMaterial
	{
		stage StructuredBuffer<float3>			PositionBuffer;
		stage StructuredBuffer<int>				PositionBufferIndex;
		stage StructuredBuffer<bool>			enabledBuffer;
		stage StructuredBuffer<bool> 			selectedBuffer;

		stage StructuredBuffer<float4>			ColorBuffer;
		stage StructuredBuffer<int>				ColorBufferIndex;


		stage StructuredBuffer<float4>			BGColorBuffer;
		stage StructuredBuffer<int>				BGColorBufferIndex;

		stage StructuredBuffer<CharPlacementUV>	CharPlacementUVBuffer;
		stage StructuredBuffer<int2>			CharStartEndBuffer;
		stage StructuredBuffer<float2>			QuadSizeBuffer;

		stage Texture2D FontTexture;				
	}

	cbuffer PerMaterial
	{
		[Color]
		stage float4 Color		= float4(1,1,1,1);

		stage bool   UseBG		= false;
		[Color]
		stage float4 BGColor	= float4(1,1,1,1);
		
		stage float	 Size = 1.0;
		stage float  screenPxRange = 16;

		stage float3 Placement = float3(0,0,0);

		stage float  borderThickness	= 0.2;
		stage float  borderRadius		= 0.5;

		stage float SelectedSaturation = 0.3;
		stage float SelectedValue = .3;
		stage float SelectedSize = 0.5;
	}

	// assign VertexID
	stage override void PreTransformPosition()
	{
		AssignVertexID();
	}

	override stage bool enabled()
	{
		return enabledBuffer[PositionBufferIndex[streams.VertexID]];
	}


	override stage float3 getQuadPos()
	{

		uint positionCount,indexCount, stride;
		PositionBuffer.GetDimensions(positionCount, stride);
		PositionBufferIndex.GetDimensions(indexCount, stride);
		return indexCount == 0 ? PositionBuffer[streams.VertexID % positionCount ] : PositionBuffer[PositionBufferIndex[streams.VertexID % indexCount] % positionCount];
	}

	override stage float2 getQuadSize()
	{
		float2 size = QuadSizeBuffer[streams.VertexID] * Size;
		if (!selectedBuffer[PositionBufferIndex[streams.VertexID]])
		{
			size = size * SelectedSize;
		}
		return size;
	}

	override stage float4 getQuadColor()
    {
		uint colorCount,indexCount, stride;
		ColorBuffer.GetDimensions(colorCount, stride);
		if (colorCount == 0) return Color;
		ColorBufferIndex.GetDimensions(indexCount, stride);
		return indexCount == 0 ? ColorBuffer[streams.VertexID % colorCount] : ColorBuffer[ColorBufferIndex[streams.VertexID % indexCount] % colorCount ];
    }

	override stage bool useBG()
    {
		return UseBG;
    }

	override stage float4 getBGQuadColor()
    {
        uint colorCount,indexCount, stride;
		BGColorBuffer.GetDimensions(colorCount, stride);
		if (colorCount == 0) return BGColor;
		BGColorBufferIndex.GetDimensions(indexCount, stride);
		float4 OutCol = indexCount == 0 ? BGColorBuffer[streams.VertexID % colorCount] : BGColorBuffer[BGColorBufferIndex[streams.VertexID % indexCount] % colorCount];
		if (!selectedBuffer[PositionBufferIndex[streams.VertexID]])
		{			
			//OutCol.xyz = HSVtoRGB(RGBtoHSV(OutCol.xyz)*float3(1,SelectedSaturation,SelectedValue));
			OutCol = float4(((OutCol.xyz - 1) * SelectedSaturation + 1) * SelectedValue,OutCol.w);
		}


		return OutCol;
    }

	override stage float4 getID()
    {
		uint posBufferCount,colBufferCount, stride;
		PositionBufferIndex.GetDimensions(posBufferCount, stride);
		ColorBufferIndex.GetDimensions(colBufferCount, stride);
        return float4(
			(float)streams.VertexID, 
			posBufferCount == 0 ? -1 : (float)PositionBufferIndex[streams.VertexID % posBufferCount],
			colBufferCount == 0 ? -1 : (float)ColorBufferIndex[streams.VertexID % colBufferCount],
			-1
		);
    }

	override stage float3 getPlacement()
    {
		return Placement;
    }

	override stage float getBorder(float2 uv)
	{

		 return getBorder( uv, QuadSizeBuffer[streams.VertexID] * Size, borderRadius, borderThickness);
	}


	override stage float getCharOpacity(float2 uv)
	{

		 return getCharOpacity( uv, CharPlacementUVBuffer, CharStartEndBuffer[streams.VertexID].x, CharStartEndBuffer[streams.VertexID].y, screenPxRange, FontTexture);
	}
};
